// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package xmongo_test

import (
	"github.com/xfrr/finantrack/internal/shared/xmongo"
	"github.com/xfrr/go-cqrsify/event"
	"sync"
	"time"
)

// Ensure, that EventMock does implement xmongo.Event.
// If this is not the case, regenerate this file with moq.
var _ xmongo.Event = &EventMock{}

// EventMock is a mock implementation of xmongo.Event.
//
//	func TestSomethingThatUsesEvent(t *testing.T) {
//
//		// make and configure a mocked xmongo.Event
//		mockedEvent := &EventMock{
//			AggregateFunc: func() *event.AggregateRef[any] {
//				panic("mock out the Aggregate method")
//			},
//			IDFunc: func() any {
//				panic("mock out the ID method")
//			},
//			PayloadFunc: func() any {
//				panic("mock out the Payload method")
//			},
//			ReasonFunc: func() string {
//				panic("mock out the Reason method")
//			},
//			TimeFunc: func() time.Time {
//				panic("mock out the Time method")
//			},
//		}
//
//		// use mockedEvent in code that requires xmongo.Event
//		// and then make assertions.
//
//	}
type EventMock struct {
	// AggregateFunc mocks the Aggregate method.
	AggregateFunc func() *event.AggregateRef[any]

	// IDFunc mocks the ID method.
	IDFunc func() any

	// PayloadFunc mocks the Payload method.
	PayloadFunc func() any

	// ReasonFunc mocks the Reason method.
	ReasonFunc func() string

	// TimeFunc mocks the Time method.
	TimeFunc func() time.Time

	// calls tracks calls to the methods.
	calls struct {
		// Aggregate holds details about calls to the Aggregate method.
		Aggregate []struct {
		}
		// ID holds details about calls to the ID method.
		ID []struct {
		}
		// Payload holds details about calls to the Payload method.
		Payload []struct {
		}
		// Reason holds details about calls to the Reason method.
		Reason []struct {
		}
		// Time holds details about calls to the Time method.
		Time []struct {
		}
	}
	lockAggregate sync.RWMutex
	lockID        sync.RWMutex
	lockPayload   sync.RWMutex
	lockReason    sync.RWMutex
	lockTime      sync.RWMutex
}

// Aggregate calls AggregateFunc.
func (mock *EventMock) Aggregate() *event.AggregateRef[any] {
	if mock.AggregateFunc == nil {
		panic("EventMock.AggregateFunc: method is nil but Event.Aggregate was just called")
	}
	callInfo := struct {
	}{}
	mock.lockAggregate.Lock()
	mock.calls.Aggregate = append(mock.calls.Aggregate, callInfo)
	mock.lockAggregate.Unlock()
	return mock.AggregateFunc()
}

// AggregateCalls gets all the calls that were made to Aggregate.
// Check the length with:
//
//	len(mockedEvent.AggregateCalls())
func (mock *EventMock) AggregateCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockAggregate.RLock()
	calls = mock.calls.Aggregate
	mock.lockAggregate.RUnlock()
	return calls
}

// ID calls IDFunc.
func (mock *EventMock) ID() any {
	if mock.IDFunc == nil {
		panic("EventMock.IDFunc: method is nil but Event.ID was just called")
	}
	callInfo := struct {
	}{}
	mock.lockID.Lock()
	mock.calls.ID = append(mock.calls.ID, callInfo)
	mock.lockID.Unlock()
	return mock.IDFunc()
}

// IDCalls gets all the calls that were made to ID.
// Check the length with:
//
//	len(mockedEvent.IDCalls())
func (mock *EventMock) IDCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockID.RLock()
	calls = mock.calls.ID
	mock.lockID.RUnlock()
	return calls
}

// Payload calls PayloadFunc.
func (mock *EventMock) Payload() any {
	if mock.PayloadFunc == nil {
		panic("EventMock.PayloadFunc: method is nil but Event.Payload was just called")
	}
	callInfo := struct {
	}{}
	mock.lockPayload.Lock()
	mock.calls.Payload = append(mock.calls.Payload, callInfo)
	mock.lockPayload.Unlock()
	return mock.PayloadFunc()
}

// PayloadCalls gets all the calls that were made to Payload.
// Check the length with:
//
//	len(mockedEvent.PayloadCalls())
func (mock *EventMock) PayloadCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockPayload.RLock()
	calls = mock.calls.Payload
	mock.lockPayload.RUnlock()
	return calls
}

// Reason calls ReasonFunc.
func (mock *EventMock) Reason() string {
	if mock.ReasonFunc == nil {
		panic("EventMock.ReasonFunc: method is nil but Event.Reason was just called")
	}
	callInfo := struct {
	}{}
	mock.lockReason.Lock()
	mock.calls.Reason = append(mock.calls.Reason, callInfo)
	mock.lockReason.Unlock()
	return mock.ReasonFunc()
}

// ReasonCalls gets all the calls that were made to Reason.
// Check the length with:
//
//	len(mockedEvent.ReasonCalls())
func (mock *EventMock) ReasonCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockReason.RLock()
	calls = mock.calls.Reason
	mock.lockReason.RUnlock()
	return calls
}

// Time calls TimeFunc.
func (mock *EventMock) Time() time.Time {
	if mock.TimeFunc == nil {
		panic("EventMock.TimeFunc: method is nil but Event.Time was just called")
	}
	callInfo := struct {
	}{}
	mock.lockTime.Lock()
	mock.calls.Time = append(mock.calls.Time, callInfo)
	mock.lockTime.Unlock()
	return mock.TimeFunc()
}

// TimeCalls gets all the calls that were made to Time.
// Check the length with:
//
//	len(mockedEvent.TimeCalls())
func (mock *EventMock) TimeCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockTime.RLock()
	calls = mock.calls.Time
	mock.lockTime.RUnlock()
	return calls
}
